6d472c4328f164f42d996f96e22fd57b
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get GET () {
        return GET;
    },
    get POST () {
        return POST;
    }
});
const _server = require("next/server");
const _nextauth = require("next-auth");
const _route = require("../auth/[...nextauth]/route");
const _prisma = require("../../lib/prisma");
async function GET() {
    try {
        const session = await (0, _nextauth.getServerSession)(_route.authOptions);
        if (!session?.user?.id) {
            return _server.NextResponse.json({
                error: 'Unauthorized'
            }, {
                status: 401
            });
        }
        // First check if user has any projects
        const projectCount = await _prisma.prisma.project.count({
            where: {
                userId: session.user.id
            }
        });
        // If no projects, return empty array immediately
        if (projectCount === 0) {
            return _server.NextResponse.json([]);
        }
        // If projects exist, fetch with includes
        const projects = await _prisma.prisma.project.findMany({
            where: {
                userId: session.user.id
            },
            include: {
                user: true,
                emailSettings: true,
                _count: {
                    select: {
                        flaggedItems: {
                            where: {
                                status: 'PENDING'
                            }
                        },
                        timelineEntries: true
                    }
                }
            },
            orderBy: [
                {
                    status: 'asc' // ACTIVE comes before ARCHIVED alphabetically
                },
                {
                    createdAt: 'desc'
                }
            ]
        });
        return _server.NextResponse.json(projects);
    } catch (error) {
        console.error('Error fetching projects:', error);
        return _server.NextResponse.json({
            error: 'Failed to fetch projects'
        }, {
            status: 500
        });
    }
}
async function POST(request) {
    console.log('=== PROJECT ENDPOINT HIT ===');
    try {
        console.log('Step 1: Getting session...');
        const session = await (0, _nextauth.getServerSession)(_route.authOptions);
        console.log('Session result:', session ? 'Found' : 'Not found', session?.user?.id);
        if (!session?.user?.id) {
            console.log('Session validation failed');
            return _server.NextResponse.json({
                error: 'Unauthorized'
            }, {
                status: 401
            });
        }
        console.log('Step 2: Parsing request body...');
        let body;
        try {
            body = await request.json();
            console.log('Body parsed successfully');
        } catch (parseError) {
            console.error('Body parsing failed:', parseError);
            return _server.NextResponse.json({
                error: 'Invalid JSON body'
            }, {
                status: 400
            });
        }
        console.log('Step 3: Extracting fields...');
        const { name, description, teamMembers, address, budget, startDate, endDate } = body;
        console.log('Received project creation request:', body);
        // Validate required fields
        if (!name || !startDate || !address || !endDate || !budget || !description) {
            console.log('Missing required fields:', {
                name: !!name,
                startDate: !!startDate,
                address: !!address,
                endDate: !!endDate,
                budget: !!budget,
                description: !!description
            });
            return _server.NextResponse.json({
                error: 'Missing required fields: name, startDate, address, endDate, budget, description'
            }, {
                status: 400
            });
        }
        // Validate team members
        if (!teamMembers || !Array.isArray(teamMembers) || teamMembers.length === 0) {
            console.log('Team members validation failed:', {
                teamMembers
            });
            return _server.NextResponse.json({
                error: 'At least one team member is required'
            }, {
                status: 400
            });
        }
        // Check for general contractor
        const hasGeneralContractor = teamMembers.some((member)=>member.role === 'GENERAL_CONTRACTOR');
        if (!hasGeneralContractor) {
            console.log('No general contractor found in team members:', teamMembers);
            return _server.NextResponse.json({
                error: 'A General Contractor is required'
            }, {
                status: 400
            });
        }
        // Validate team member structure
        for (const member of teamMembers){
            if (!member.name || !member.email || !member.role) {
                console.log('Team member validation failed:', member);
                return _server.NextResponse.json({
                    error: 'All team members must have name, email, and role'
                }, {
                    status: 400
                });
            }
        }
        // Get the general contractor info for backward compatibility
        const generalContractor = teamMembers.find((member)=>member.role === 'GENERAL_CONTRACTOR');
        console.log('=== PROJECT CREATION DEBUG ===');
        console.log('Raw form data received:', {
            name: typeof name + ': ' + name,
            description: typeof description + ': ' + description,
            address: typeof address + ': ' + address,
            budget: typeof budget + ': ' + budget,
            startDate: typeof startDate + ': ' + startDate,
            endDate: typeof endDate + ': ' + endDate,
            teamMembers: teamMembers.map((m)=>({
                    name: typeof m.name + ': ' + m.name,
                    email: typeof m.email + ': ' + m.email,
                    role: typeof m.role + ': ' + m.role
                }))
        });
        // Parse and validate budget
        let parsedBudget;
        try {
            parsedBudget = typeof budget === 'string' ? parseFloat(budget.replace(/[,$]/g, '')) : Number(budget);
            if (isNaN(parsedBudget)) {
                throw new Error('Invalid budget value');
            }
            console.log('Parsed budget:', parsedBudget);
        } catch (error) {
            console.error('Budget parsing error:', error);
            return _server.NextResponse.json({
                error: 'Invalid budget format'
            }, {
                status: 400
            });
        }
        // Parse and validate dates
        let parsedStartDate, parsedEndDate;
        try {
            parsedStartDate = new Date(startDate);
            parsedEndDate = new Date(endDate);
            if (isNaN(parsedStartDate.getTime()) || isNaN(parsedEndDate.getTime())) {
                throw new Error('Invalid date values');
            }
            console.log('Parsed dates:', {
                startDate: parsedStartDate,
                endDate: parsedEndDate
            });
        } catch (error) {
            console.error('Date parsing error:', error);
            return _server.NextResponse.json({
                error: 'Invalid date format'
            }, {
                status: 400
            });
        }
        // Validate team member roles
        const validRoles = [
            'GENERAL_CONTRACTOR',
            'ARCHITECT_DESIGNER',
            'PROJECT_MANAGER'
        ];
        for (const member of teamMembers){
            if (!validRoles.includes(member.role)) {
                console.error('Invalid role:', member.role);
                return _server.NextResponse.json({
                    error: `Invalid role: ${member.role}`
                }, {
                    status: 400
                });
            }
        }
        console.log('All validations passed, creating project...');
        // Create project first without nested creates
        const project = await _prisma.prisma.project.create({
            data: {
                name: String(name),
                description: String(description),
                contractor: generalContractor?.name || null,
                address: String(address),
                budget: parsedBudget,
                startDate: parsedStartDate,
                endDate: parsedEndDate,
                userId: session.user.id
            }
        });
        console.log('Project created successfully:', project.id);
        // For now, let's just return the project without creating team members or email settings
        // to isolate where the failure is happening
        console.log('Returning project without creating related records for debugging...');
        return _server.NextResponse.json(project, {
            status: 201
        });
    /* TEMPORARILY COMMENTED OUT FOR DEBUGGING
    // Create team members separately using correct model name
    for (const member of teamMembers) {
      console.log('Creating team member:', member);
      try {
        await (prisma as any).teamMember.create({
          data: {
            name: String(member.name),
            email: String(member.email),
            role: member.role,
            projectId: project.id
          }
        });
        console.log('Team member created successfully:', member.name);
      } catch (error) {
        console.error('Team member creation failed:', error);
        throw new Error(`Failed to create team member ${member.name}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    // Create email settings separately
    console.log('Creating email settings...');
    try {
      await prisma.emailSettings.create({
        data: {
          projectId: project.id,
          monitoringEnabled: true,
          gmailConnected: true,
          emailFilters: {
            contractorEmail: generalContractor?.email,
            teamEmails: teamMembers.map(member => member.email),
          },
          notificationsEnabled: true,
          weeklyReports: true,
          highPriorityAlerts: true,
        }
      });
      console.log('Email settings created successfully');
    } catch (error) {
      console.error('Email settings creation failed:', error);
      throw new Error(`Failed to create email settings: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }

    console.log('Project creation completed successfully');

    return NextResponse.json(project, { status: 201 })
    */ } catch (error) {
        console.error('Error creating project:', error);
        return _server.NextResponse.json({
            error: 'Failed to create project'
        }, {
            status: 500
        });
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9rZW5ueWMvY29kZS9wZXJzb25hbC9uYWlsaXQvYXBwL2FwaS9wcm9qZWN0cy9yb3V0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInXG5pbXBvcnQgeyBnZXRTZXJ2ZXJTZXNzaW9uIH0gZnJvbSAnbmV4dC1hdXRoJ1xuaW1wb3J0IHsgYXV0aE9wdGlvbnMgfSBmcm9tICcuLi9hdXRoL1suLi5uZXh0YXV0aF0vcm91dGUnXG5pbXBvcnQgeyBwcmlzbWEgfSBmcm9tICcuLi8uLi9saWIvcHJpc21hJ1xuXG4vLyBHRVQgL2FwaS9wcm9qZWN0cyAtIEdldCBhbGwgcHJvamVjdHMgZm9yIGF1dGhlbnRpY2F0ZWQgdXNlclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIEdFVCgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgZ2V0U2VydmVyU2Vzc2lvbihhdXRoT3B0aW9ucylcbiAgICBcbiAgICBpZiAoIXNlc3Npb24/LnVzZXI/LmlkKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ1VuYXV0aG9yaXplZCcgfSwgeyBzdGF0dXM6IDQwMSB9KVxuICAgIH1cblxuICAgIC8vIEZpcnN0IGNoZWNrIGlmIHVzZXIgaGFzIGFueSBwcm9qZWN0c1xuICAgIGNvbnN0IHByb2plY3RDb3VudCA9IGF3YWl0IHByaXNtYS5wcm9qZWN0LmNvdW50KHtcbiAgICAgIHdoZXJlOiB7XG4gICAgICAgIHVzZXJJZDogc2Vzc2lvbi51c2VyLmlkXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBJZiBubyBwcm9qZWN0cywgcmV0dXJuIGVtcHR5IGFycmF5IGltbWVkaWF0ZWx5XG4gICAgaWYgKHByb2plY3RDb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFtdKTtcbiAgICB9XG5cbiAgICAvLyBJZiBwcm9qZWN0cyBleGlzdCwgZmV0Y2ggd2l0aCBpbmNsdWRlc1xuICAgIGNvbnN0IHByb2plY3RzID0gYXdhaXQgcHJpc21hLnByb2plY3QuZmluZE1hbnkoe1xuICAgICAgd2hlcmU6IHtcbiAgICAgICAgdXNlcklkOiBzZXNzaW9uLnVzZXIuaWRcbiAgICAgIH0sXG4gICAgICBpbmNsdWRlOiB7XG4gICAgICAgIHVzZXI6IHRydWUsXG4gICAgICAgIGVtYWlsU2V0dGluZ3M6IHRydWUsXG4gICAgICAgIF9jb3VudDoge1xuICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgZmxhZ2dlZEl0ZW1zOiB7XG4gICAgICAgICAgICAgIHdoZXJlOiB7IHN0YXR1czogJ1BFTkRJTkcnIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1lbGluZUVudHJpZXM6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcmRlckJ5OiBbXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0dXM6ICdhc2MnIC8vIEFDVElWRSBjb21lcyBiZWZvcmUgQVJDSElWRUQgYWxwaGFiZXRpY2FsbHlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNyZWF0ZWRBdDogJ2Rlc2MnXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KVxuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHByb2plY3RzKVxuICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2plY3RzOicsIGVycm9yKVxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gZmV0Y2ggcHJvamVjdHMnIH0sXG4gICAgICB7IHN0YXR1czogNTAwIH1cbiAgICApXG4gIH1cbn1cblxuLy8gUE9TVCAvYXBpL3Byb2plY3RzIC0gQ3JlYXRlIGEgbmV3IHByb2plY3RcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIGNvbnNvbGUubG9nKCc9PT0gUFJPSkVDVCBFTkRQT0lOVCBISVQgPT09Jyk7XG4gIFxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdTdGVwIDE6IEdldHRpbmcgc2Vzc2lvbi4uLicpO1xuICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBnZXRTZXJ2ZXJTZXNzaW9uKGF1dGhPcHRpb25zKVxuICAgIGNvbnNvbGUubG9nKCdTZXNzaW9uIHJlc3VsdDonLCBzZXNzaW9uID8gJ0ZvdW5kJyA6ICdOb3QgZm91bmQnLCBzZXNzaW9uPy51c2VyPy5pZCk7XG4gICAgXG4gICAgaWYgKCFzZXNzaW9uPy51c2VyPy5pZCkge1xuICAgICAgY29uc29sZS5sb2coJ1Nlc3Npb24gdmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnVW5hdXRob3JpemVkJyB9LCB7IHN0YXR1czogNDAxIH0pXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N0ZXAgMjogUGFyc2luZyByZXF1ZXN0IGJvZHkuLi4nKTtcbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlcXVlc3QuanNvbigpXG4gICAgICBjb25zb2xlLmxvZygnQm9keSBwYXJzZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQm9keSBwYXJzaW5nIGZhaWxlZDonLCBwYXJzZUVycm9yKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnSW52YWxpZCBKU09OIGJvZHknIH0sIHsgc3RhdHVzOiA0MDAgfSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdTdGVwIDM6IEV4dHJhY3RpbmcgZmllbGRzLi4uJyk7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgdGVhbU1lbWJlcnMsXG4gICAgICBhZGRyZXNzLFxuICAgICAgYnVkZ2V0LFxuICAgICAgc3RhcnREYXRlLFxuICAgICAgZW5kRGF0ZSxcbiAgICB9ID0gYm9keVxuXG4gICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIHByb2plY3QgY3JlYXRpb24gcmVxdWVzdDonLCBib2R5KVxuICAgIFxuICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkc1xuICAgIGlmICghbmFtZSB8fCAhc3RhcnREYXRlIHx8ICFhZGRyZXNzIHx8ICFlbmREYXRlIHx8ICFidWRnZXQgfHwgIWRlc2NyaXB0aW9uKSB7XG4gICAgICBjb25zb2xlLmxvZygnTWlzc2luZyByZXF1aXJlZCBmaWVsZHM6JywgeyBcbiAgICAgICAgbmFtZTogISFuYW1lLCBcbiAgICAgICAgc3RhcnREYXRlOiAhIXN0YXJ0RGF0ZSwgXG4gICAgICAgIGFkZHJlc3M6ICEhYWRkcmVzcyxcbiAgICAgICAgZW5kRGF0ZTogISFlbmREYXRlLFxuICAgICAgICBidWRnZXQ6ICEhYnVkZ2V0LFxuICAgICAgICBkZXNjcmlwdGlvbjogISFkZXNjcmlwdGlvblxuICAgICAgfSlcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ01pc3NpbmcgcmVxdWlyZWQgZmllbGRzOiBuYW1lLCBzdGFydERhdGUsIGFkZHJlc3MsIGVuZERhdGUsIGJ1ZGdldCwgZGVzY3JpcHRpb24nIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHRlYW0gbWVtYmVyc1xuICAgIGlmICghdGVhbU1lbWJlcnMgfHwgIUFycmF5LmlzQXJyYXkodGVhbU1lbWJlcnMpIHx8IHRlYW1NZW1iZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ1RlYW0gbWVtYmVycyB2YWxpZGF0aW9uIGZhaWxlZDonLCB7IHRlYW1NZW1iZXJzIH0pXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdBdCBsZWFzdCBvbmUgdGVhbSBtZW1iZXIgaXMgcmVxdWlyZWQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBnZW5lcmFsIGNvbnRyYWN0b3JcbiAgICBjb25zdCBoYXNHZW5lcmFsQ29udHJhY3RvciA9IHRlYW1NZW1iZXJzLnNvbWUobWVtYmVyID0+IFxuICAgICAgbWVtYmVyLnJvbGUgPT09ICdHRU5FUkFMX0NPTlRSQUNUT1InXG4gICAgKTtcblxuICAgIGlmICghaGFzR2VuZXJhbENvbnRyYWN0b3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdObyBnZW5lcmFsIGNvbnRyYWN0b3IgZm91bmQgaW4gdGVhbSBtZW1iZXJzOicsIHRlYW1NZW1iZXJzKVxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnQSBHZW5lcmFsIENvbnRyYWN0b3IgaXMgcmVxdWlyZWQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHRlYW0gbWVtYmVyIHN0cnVjdHVyZVxuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHRlYW1NZW1iZXJzKSB7XG4gICAgICBpZiAoIW1lbWJlci5uYW1lIHx8ICFtZW1iZXIuZW1haWwgfHwgIW1lbWJlci5yb2xlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdUZWFtIG1lbWJlciB2YWxpZGF0aW9uIGZhaWxlZDonLCBtZW1iZXIpXG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICB7IGVycm9yOiAnQWxsIHRlYW0gbWVtYmVycyBtdXN0IGhhdmUgbmFtZSwgZW1haWwsIGFuZCByb2xlJyB9LFxuICAgICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBnZW5lcmFsIGNvbnRyYWN0b3IgaW5mbyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGNvbnN0IGdlbmVyYWxDb250cmFjdG9yID0gdGVhbU1lbWJlcnMuZmluZChtZW1iZXIgPT4gbWVtYmVyLnJvbGUgPT09ICdHRU5FUkFMX0NPTlRSQUNUT1InKTtcblxuICAgIGNvbnNvbGUubG9nKCc9PT0gUFJPSkVDVCBDUkVBVElPTiBERUJVRyA9PT0nKTtcbiAgICBjb25zb2xlLmxvZygnUmF3IGZvcm0gZGF0YSByZWNlaXZlZDonLCB7XG4gICAgICBuYW1lOiB0eXBlb2YgbmFtZSArICc6ICcgKyBuYW1lLFxuICAgICAgZGVzY3JpcHRpb246IHR5cGVvZiBkZXNjcmlwdGlvbiArICc6ICcgKyBkZXNjcmlwdGlvbixcbiAgICAgIGFkZHJlc3M6IHR5cGVvZiBhZGRyZXNzICsgJzogJyArIGFkZHJlc3MsXG4gICAgICBidWRnZXQ6IHR5cGVvZiBidWRnZXQgKyAnOiAnICsgYnVkZ2V0LFxuICAgICAgc3RhcnREYXRlOiB0eXBlb2Ygc3RhcnREYXRlICsgJzogJyArIHN0YXJ0RGF0ZSxcbiAgICAgIGVuZERhdGU6IHR5cGVvZiBlbmREYXRlICsgJzogJyArIGVuZERhdGUsXG4gICAgICB0ZWFtTWVtYmVyczogdGVhbU1lbWJlcnMubWFwKG0gPT4gKHtcbiAgICAgICAgbmFtZTogdHlwZW9mIG0ubmFtZSArICc6ICcgKyBtLm5hbWUsXG4gICAgICAgIGVtYWlsOiB0eXBlb2YgbS5lbWFpbCArICc6ICcgKyBtLmVtYWlsLFxuICAgICAgICByb2xlOiB0eXBlb2YgbS5yb2xlICsgJzogJyArIG0ucm9sZVxuICAgICAgfSkpXG4gICAgfSk7XG5cbiAgICAvLyBQYXJzZSBhbmQgdmFsaWRhdGUgYnVkZ2V0XG4gICAgbGV0IHBhcnNlZEJ1ZGdldDogbnVtYmVyO1xuICAgIHRyeSB7XG4gICAgICBwYXJzZWRCdWRnZXQgPSB0eXBlb2YgYnVkZ2V0ID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQoYnVkZ2V0LnJlcGxhY2UoL1ssJF0vZywgJycpKSA6IE51bWJlcihidWRnZXQpO1xuICAgICAgaWYgKGlzTmFOKHBhcnNlZEJ1ZGdldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ1ZGdldCB2YWx1ZScpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coJ1BhcnNlZCBidWRnZXQ6JywgcGFyc2VkQnVkZ2V0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQnVkZ2V0IHBhcnNpbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnSW52YWxpZCBidWRnZXQgZm9ybWF0JyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBhbmQgdmFsaWRhdGUgZGF0ZXNcbiAgICBsZXQgcGFyc2VkU3RhcnREYXRlOiBEYXRlLCBwYXJzZWRFbmREYXRlOiBEYXRlO1xuICAgIHRyeSB7XG4gICAgICBwYXJzZWRTdGFydERhdGUgPSBuZXcgRGF0ZShzdGFydERhdGUpO1xuICAgICAgcGFyc2VkRW5kRGF0ZSA9IG5ldyBEYXRlKGVuZERhdGUpO1xuICAgICAgXG4gICAgICBpZiAoaXNOYU4ocGFyc2VkU3RhcnREYXRlLmdldFRpbWUoKSkgfHwgaXNOYU4ocGFyc2VkRW5kRGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRlIHZhbHVlcycpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coJ1BhcnNlZCBkYXRlczonLCB7IHN0YXJ0RGF0ZTogcGFyc2VkU3RhcnREYXRlLCBlbmREYXRlOiBwYXJzZWRFbmREYXRlIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdEYXRlIHBhcnNpbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnSW52YWxpZCBkYXRlIGZvcm1hdCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGVhbSBtZW1iZXIgcm9sZXNcbiAgICBjb25zdCB2YWxpZFJvbGVzID0gWydHRU5FUkFMX0NPTlRSQUNUT1InLCAnQVJDSElURUNUX0RFU0lHTkVSJywgJ1BST0pFQ1RfTUFOQUdFUiddO1xuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHRlYW1NZW1iZXJzKSB7XG4gICAgICBpZiAoIXZhbGlkUm9sZXMuaW5jbHVkZXMobWVtYmVyLnJvbGUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgcm9sZTonLCBtZW1iZXIucm9sZSk7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICB7IGVycm9yOiBgSW52YWxpZCByb2xlOiAke21lbWJlci5yb2xlfWAgfSxcbiAgICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdBbGwgdmFsaWRhdGlvbnMgcGFzc2VkLCBjcmVhdGluZyBwcm9qZWN0Li4uJyk7XG5cbiAgICAvLyBDcmVhdGUgcHJvamVjdCBmaXJzdCB3aXRob3V0IG5lc3RlZCBjcmVhdGVzXG4gICAgY29uc3QgcHJvamVjdCA9IGF3YWl0IHByaXNtYS5wcm9qZWN0LmNyZWF0ZSh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIG5hbWU6IFN0cmluZyhuYW1lKSxcbiAgICAgICAgZGVzY3JpcHRpb246IFN0cmluZyhkZXNjcmlwdGlvbiksXG4gICAgICAgIGNvbnRyYWN0b3I6IGdlbmVyYWxDb250cmFjdG9yPy5uYW1lIHx8IG51bGwsXG4gICAgICAgIGFkZHJlc3M6IFN0cmluZyhhZGRyZXNzKSxcbiAgICAgICAgYnVkZ2V0OiBwYXJzZWRCdWRnZXQsXG4gICAgICAgIHN0YXJ0RGF0ZTogcGFyc2VkU3RhcnREYXRlLFxuICAgICAgICBlbmREYXRlOiBwYXJzZWRFbmREYXRlLFxuICAgICAgICB1c2VySWQ6IHNlc3Npb24udXNlci5pZFxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coJ1Byb2plY3QgY3JlYXRlZCBzdWNjZXNzZnVsbHk6JywgcHJvamVjdC5pZCk7XG5cbiAgICAvLyBGb3Igbm93LCBsZXQncyBqdXN0IHJldHVybiB0aGUgcHJvamVjdCB3aXRob3V0IGNyZWF0aW5nIHRlYW0gbWVtYmVycyBvciBlbWFpbCBzZXR0aW5nc1xuICAgIC8vIHRvIGlzb2xhdGUgd2hlcmUgdGhlIGZhaWx1cmUgaXMgaGFwcGVuaW5nXG4gICAgY29uc29sZS5sb2coJ1JldHVybmluZyBwcm9qZWN0IHdpdGhvdXQgY3JlYXRpbmcgcmVsYXRlZCByZWNvcmRzIGZvciBkZWJ1Z2dpbmcuLi4nKTtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24ocHJvamVjdCwgeyBzdGF0dXM6IDIwMSB9KVxuXG4gICAgLyogVEVNUE9SQVJJTFkgQ09NTUVOVEVEIE9VVCBGT1IgREVCVUdHSU5HXG4gICAgLy8gQ3JlYXRlIHRlYW0gbWVtYmVycyBzZXBhcmF0ZWx5IHVzaW5nIGNvcnJlY3QgbW9kZWwgbmFtZVxuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHRlYW1NZW1iZXJzKSB7XG4gICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgdGVhbSBtZW1iZXI6JywgbWVtYmVyKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IChwcmlzbWEgYXMgYW55KS50ZWFtTWVtYmVyLmNyZWF0ZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgbmFtZTogU3RyaW5nKG1lbWJlci5uYW1lKSxcbiAgICAgICAgICAgIGVtYWlsOiBTdHJpbmcobWVtYmVyLmVtYWlsKSxcbiAgICAgICAgICAgIHJvbGU6IG1lbWJlci5yb2xlLFxuICAgICAgICAgICAgcHJvamVjdElkOiBwcm9qZWN0LmlkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coJ1RlYW0gbWVtYmVyIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5OicsIG1lbWJlci5uYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RlYW0gbWVtYmVyIGNyZWF0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSB0ZWFtIG1lbWJlciAke21lbWJlci5uYW1lfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgZW1haWwgc2V0dGluZ3Mgc2VwYXJhdGVseVxuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBlbWFpbCBzZXR0aW5ncy4uLicpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcmlzbWEuZW1haWxTZXR0aW5ncy5jcmVhdGUoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcHJvamVjdElkOiBwcm9qZWN0LmlkLFxuICAgICAgICAgIG1vbml0b3JpbmdFbmFibGVkOiB0cnVlLFxuICAgICAgICAgIGdtYWlsQ29ubmVjdGVkOiB0cnVlLFxuICAgICAgICAgIGVtYWlsRmlsdGVyczoge1xuICAgICAgICAgICAgY29udHJhY3RvckVtYWlsOiBnZW5lcmFsQ29udHJhY3Rvcj8uZW1haWwsXG4gICAgICAgICAgICB0ZWFtRW1haWxzOiB0ZWFtTWVtYmVycy5tYXAobWVtYmVyID0+IG1lbWJlci5lbWFpbCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBub3RpZmljYXRpb25zRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICB3ZWVrbHlSZXBvcnRzOiB0cnVlLFxuICAgICAgICAgIGhpZ2hQcmlvcml0eUFsZXJ0czogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZygnRW1haWwgc2V0dGluZ3MgY3JlYXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRW1haWwgc2V0dGluZ3MgY3JlYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBlbWFpbCBzZXR0aW5nczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnUHJvamVjdCBjcmVhdGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24ocHJvamVjdCwgeyBzdGF0dXM6IDIwMSB9KVxuICAgICovXG4gIH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgcHJvamVjdDonLCBlcnJvcilcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiAnRmFpbGVkIHRvIGNyZWF0ZSBwcm9qZWN0JyB9LFxuICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgKVxuICB9XG59ICJdLCJuYW1lcyI6WyJHRVQiLCJQT1NUIiwic2Vzc2lvbiIsImdldFNlcnZlclNlc3Npb24iLCJhdXRoT3B0aW9ucyIsInVzZXIiLCJpZCIsIk5leHRSZXNwb25zZSIsImpzb24iLCJlcnJvciIsInN0YXR1cyIsInByb2plY3RDb3VudCIsInByaXNtYSIsInByb2plY3QiLCJjb3VudCIsIndoZXJlIiwidXNlcklkIiwicHJvamVjdHMiLCJmaW5kTWFueSIsImluY2x1ZGUiLCJlbWFpbFNldHRpbmdzIiwiX2NvdW50Iiwic2VsZWN0IiwiZmxhZ2dlZEl0ZW1zIiwidGltZWxpbmVFbnRyaWVzIiwib3JkZXJCeSIsImNyZWF0ZWRBdCIsImNvbnNvbGUiLCJyZXF1ZXN0IiwibG9nIiwiYm9keSIsInBhcnNlRXJyb3IiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJ0ZWFtTWVtYmVycyIsImFkZHJlc3MiLCJidWRnZXQiLCJzdGFydERhdGUiLCJlbmREYXRlIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiaGFzR2VuZXJhbENvbnRyYWN0b3IiLCJzb21lIiwibWVtYmVyIiwicm9sZSIsImVtYWlsIiwiZ2VuZXJhbENvbnRyYWN0b3IiLCJmaW5kIiwibWFwIiwibSIsInBhcnNlZEJ1ZGdldCIsInBhcnNlRmxvYXQiLCJyZXBsYWNlIiwiTnVtYmVyIiwiaXNOYU4iLCJFcnJvciIsInBhcnNlZFN0YXJ0RGF0ZSIsInBhcnNlZEVuZERhdGUiLCJEYXRlIiwiZ2V0VGltZSIsInZhbGlkUm9sZXMiLCJpbmNsdWRlcyIsImNyZWF0ZSIsImRhdGEiLCJTdHJpbmciLCJjb250cmFjdG9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztRQU1zQkE7ZUFBQUE7O1FBMERBQztlQUFBQTs7O3dCQWhFb0I7MEJBQ1Q7dUJBQ0w7d0JBQ0w7QUFHaEIsZUFBZUQ7SUFDcEIsSUFBSTtRQUNGLE1BQU1FLFVBQVUsTUFBTUMsSUFBQUEsMEJBQWdCLEVBQUNDLGtCQUFXO1FBRWxELElBQUksQ0FBQ0YsU0FBU0csTUFBTUMsSUFBSTtZQUN0QixPQUFPQyxvQkFBWSxDQUFDQyxJQUFJLENBQUM7Z0JBQUVDLE9BQU87WUFBZSxHQUFHO2dCQUFFQyxRQUFRO1lBQUk7UUFDcEU7UUFFQSx1Q0FBdUM7UUFDdkMsTUFBTUMsZUFBZSxNQUFNQyxjQUFNLENBQUNDLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDO1lBQzlDQyxPQUFPO2dCQUNMQyxRQUFRZCxRQUFRRyxJQUFJLENBQUNDLEVBQUU7WUFDekI7UUFDRjtRQUVBLGlEQUFpRDtRQUNqRCxJQUFJSyxpQkFBaUIsR0FBRztZQUN0QixPQUFPSixvQkFBWSxDQUFDQyxJQUFJLENBQUMsRUFBRTtRQUM3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